<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fingerprint Forensic Analyzer | Punjab Investigation Tools</title>
    <meta name="description" content="Advanced dermatoglyphics analysis tool for fingerprint pattern classification, minutiae detection, and forensic comparison.">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="stylesheet" href="../css/tool-common.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
</head>
<body>
    <header class="header">
        <div class="header-container">
            <a href="/" class="logo" style="text-decoration: none; color: inherit;">
                <div class="logo-icon">
                    <i class="fas fa-shield-halved"></i>
                </div>
                <div class="logo-text">
                    <span class="logo-title">Punjab Investigation Tools</span>
                    <span class="logo-subtitle">Fingerprint Forensic Analyzer</span>
                </div>
            </a>
            <div class="header-actions">
                <a href="/" class="back-home-btn">
                    <i class="fas fa-home"></i> All Tools
                </a>
            </div>
        </div>
    </header>

    <main class="main-content">
        <section class="hero-section">
            <div class="hero-content">
                <h1><i class="fas fa-fingerprint"></i> Fingerprint Forensic Analyzer</h1>
                <p>Advanced dermatoglyphics analysis: Pattern classification, minutiae detection, ridge counting & forensic comparison</p>
            </div>
        </section>

        <!-- Mode Selection Tabs -->
        <section class="mode-section">
            <div class="mode-tabs">
                <button class="mode-tab active" onclick="switchMode('analyze')" id="analyzeTab">
                    <i class="fas fa-microscope"></i> Single Analysis
                </button>
                <button class="mode-tab" onclick="switchMode('compare')" id="compareTab">
                    <i class="fas fa-scale-balanced"></i> Compare Prints
                </button>
            </div>
        </section>

        <!-- Single Analysis Mode -->
        <section class="analyze-section" id="analyzeSection">
            <div class="upload-container">
                <div class="file-drop-zone large-drop" id="analyzeDropZone" onclick="document.getElementById('analyzeInput').click()">
                    <i class="fas fa-fingerprint"></i>
                    <h4>Upload Fingerprint Image</h4>
                    <p>Drop latent, patent, or plastic print image here</p>
                    <p style="font-size: 0.8rem; color: var(--text-secondary); margin-top: 10px;">Supports: JPG, PNG, BMP, TIFF</p>
                    <input type="file" id="analyzeInput" accept="image/*" hidden>
                </div>
                <div class="preview-container" id="analyzePreview" style="display: none;">
                    <div class="preview-wrapper">
                        <canvas id="originalCanvas"></canvas>
                        <div class="preview-label">Original</div>
                    </div>
                    <div class="preview-wrapper">
                        <canvas id="enhancedCanvas"></canvas>
                        <div class="preview-label">Enhanced</div>
                    </div>
                    <div class="preview-wrapper">
                        <canvas id="minutiaeCanvas"></canvas>
                        <div class="preview-label">Minutiae Map</div>
                    </div>
                </div>
            </div>

            <div class="analyze-actions" style="text-align: center; margin-top: 20px;">
                <button class="verify-btn" onclick="analyzeFingerprint()" id="analyzeBtn" disabled>
                    <i class="fas fa-search-plus"></i> Analyze Fingerprint
                </button>
                <button class="action-btn" onclick="resetAnalysis()" style="margin-left: 10px;">
                    <i class="fas fa-redo"></i> Reset
                </button>
            </div>
        </section>

        <!-- Compare Mode -->
        <section class="compare-section" id="compareSection" style="display: none;">
            <div class="compare-container">
                <div class="file-drop-zone" id="dropZone1" onclick="document.getElementById('fileInput1').click()">
                    <i class="fas fa-fingerprint"></i>
                    <h4>Fingerprint 1 (Known)</h4>
                    <p>Reference print for comparison</p>
                    <input type="file" id="fileInput1" accept="image/*" hidden>
                    <div class="image-preview" id="preview1" style="display: none;">
                        <img id="img1" alt="Fingerprint 1">
                    </div>
                </div>

                <div class="vs-indicator">
                    <i class="fas fa-arrows-left-right"></i>
                </div>

                <div class="file-drop-zone" id="dropZone2" onclick="document.getElementById('fileInput2').click()">
                    <i class="fas fa-fingerprint"></i>
                    <h4>Fingerprint 2 (Questioned)</h4>
                    <p>Latent/unknown print to match</p>
                    <input type="file" id="fileInput2" accept="image/*" hidden>
                    <div class="image-preview" id="preview2" style="display: none;">
                        <img id="img2" alt="Fingerprint 2">
                    </div>
                </div>
            </div>

            <div class="compare-actions" style="text-align: center; margin-top: 20px;">
                <button class="verify-btn" onclick="matchFingerprints()" id="matchBtn" disabled>
                    <i class="fas fa-scale-balanced"></i> Compare Fingerprints
                </button>
            </div>
        </section>

        <!-- Analysis Results Section -->
        <section class="results-section" id="analysisResults" style="display: none;">
            <div class="result-card">
                <div class="result-header">
                    <div class="result-icon valid" id="analysisIcon">
                        <i class="fas fa-fingerprint"></i>
                    </div>
                    <div class="result-title">
                        <h3 id="analysisTitle">Dermatoglyphic Analysis Complete</h3>
                        <p id="analysisSubtitle">Pattern and minutiae detected</p>
                    </div>
                </div>

                <!-- Pattern Classification -->
                <div class="analysis-section">
                    <h4><i class="fas fa-shapes"></i> Pattern Classification (Henry System)</h4>
                    <div class="pattern-display" id="patternDisplay">
                        <!-- Pattern type will be shown here -->
                    </div>
                </div>

                <!-- Ridge Details -->
                <div class="analysis-section">
                    <h4><i class="fas fa-wave-square"></i> Ridge Analysis</h4>
                    <div class="ridge-stats" id="ridgeStats">
                        <!-- Ridge statistics -->
                    </div>
                </div>

                <!-- Minutiae Detection -->
                <div class="analysis-section">
                    <h4><i class="fas fa-crosshairs"></i> Minutiae Detection</h4>
                    <div class="minutiae-display" id="minutiaeDisplay">
                        <!-- Minutiae details -->
                    </div>
                </div>

                <!-- Core & Delta Points -->
                <div class="analysis-section">
                    <h4><i class="fas fa-bullseye"></i> Singular Points</h4>
                    <div class="singular-points" id="singularPoints">
                        <!-- Core and delta information -->
                    </div>
                </div>

                <!-- Quality Assessment -->
                <div class="analysis-section">
                    <h4><i class="fas fa-chart-line"></i> Quality Assessment</h4>
                    <div class="quality-display" id="qualityDisplay">
                        <!-- Quality metrics -->
                    </div>
                </div>
            </div>

            <div class="warning-box" style="background: rgba(99, 102, 241, 0.1); border-color: rgba(99, 102, 241, 0.3);">
                <h4 style="color: #6366f1;"><i class="fas fa-info-circle"></i> Dermatoglyphics Science</h4>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li><strong>Friction ridges</strong> form unique patterns (loops, whorls, arches) used for identification</li>
                    <li><strong>Minutiae</strong> are ridge characteristics (endings, bifurcations) - typically 100-150 per print</li>
                    <li><strong>12+ matching minutiae</strong> is generally required for positive identification</li>
                    <li>Patterns are permanent, individualistic, and unique even for identical twins</li>
                </ul>
            </div>

            <div class="action-buttons">
                <button class="action-btn" onclick="copyAnalysisReport()">
                    <i class="fas fa-copy"></i> Copy Report
                </button>
                <button class="action-btn" onclick="downloadAnalysisPDF()">
                    <i class="fas fa-file-pdf"></i> Download PDF
                </button>
                <button class="action-btn" onclick="resetAnalysis()">
                    <i class="fas fa-redo"></i> New Analysis
                </button>
            </div>
        </section>

        <!-- Comparison Results Section -->
        <section class="results-section" id="resultsSection" style="display: none;">
            <div class="result-card">
                <div class="result-header">
                    <div class="result-icon" id="resultIcon">
                        <i class="fas fa-hand-dots"></i>
                    </div>
                    <div class="result-title">
                        <h3 id="resultTitle">Comparison Analysis Result</h3>
                        <p id="resultSubtitle">Comparison complete</p>
                    </div>
                </div>

                <div class="similarity-display" id="similarityDisplay">
                    <!-- Similarity meter will be shown here -->
                </div>

                <div class="comparison-details" id="comparisonDetails">
                    <!-- Side by side analysis -->
                </div>

                <div class="result-details" id="resultDetails">
                    <!-- Analysis details -->
                </div>
            </div>

            <div class="warning-box">
                <h4><i class="fas fa-triangle-exclamation"></i> Important Disclaimer</h4>
                <ul style="margin-left: 20px; margin-top: 10px;">
                    <li><strong>This is a screening tool</strong> - Uses pattern analysis and minutiae comparison algorithms</li>
                    <li>This tool is NOT a certified AFIS (Automated Fingerprint Identification System)</li>
                    <li>Results should be used for <strong>preliminary screening only</strong></li>
                    <li>For legal proceedings, professional forensic analysis by certified experts is required</li>
                    <li>Image quality, orientation, and partial prints significantly affect accuracy</li>
                </ul>
            </div>

            <div class="action-buttons">
                <button class="action-btn" onclick="copyResult()">
                    <i class="fas fa-copy"></i> Copy Report
                </button>
                <button class="action-btn" onclick="resetMatcher()">
                    <i class="fas fa-redo"></i> Compare New Prints
                </button>
            </div>
        </section>

        <!-- Dermatoglyphics Info Section -->
        <section class="info-section">
            <h3><i class="fas fa-graduation-cap"></i> Dermatoglyphics Science</h3>
            <div class="info-grid">
                <div class="info-card">
                    <div class="info-icon"><i class="fas fa-shapes"></i></div>
                    <h4>Pattern Types (Henry Classification)</h4>
                    <p><strong>Loops</strong> (60-65%): Ulnar & Radial loops with one delta. <strong>Whorls</strong> (30-35%): Spiral/circular with two deltas. <strong>Arches</strong> (5%): Plain & tented, no delta.</p>
                </div>
                <div class="info-card">
                    <div class="info-icon"><i class="fas fa-crosshairs"></i></div>
                    <h4>Minutiae Points</h4>
                    <p><strong>Ridge endings</strong>: Where a ridge stops. <strong>Bifurcations</strong>: Where ridges split. <strong>Dots</strong>: Short ridges. <strong>Islands/Lakes</strong>: Enclosed spaces. Used for ACE-V methodology.</p>
                </div>
                <div class="info-card">
                    <div class="info-icon"><i class="fas fa-bullseye"></i></div>
                    <h4>Singular Points</h4>
                    <p><strong>Core</strong>: Center/focal point of pattern. <strong>Delta</strong>: Triangular ridge meeting point. Position used for ridge counting and classification.</p>
                </div>
                <div class="info-card">
                    <div class="info-icon"><i class="fas fa-flask"></i></div>
                    <h4>Print Development</h4>
                    <p><strong>Latent</strong>: Invisible, needs powder/chemicals. <strong>Patent</strong>: Visible (blood, ink). <strong>Plastic</strong>: 3D impression. Methods: Powder dusting, Ninhydrin, Superglue fuming, DFO.</p>
                </div>
                <div class="info-card">
                    <div class="info-icon"><i class="fas fa-scale-balanced"></i></div>
                    <h4>ACE-V Methodology</h4>
                    <p><strong>Analysis</strong>: Assess print quality. <strong>Comparison</strong>: Compare minutiae. <strong>Evaluation</strong>: Make identification decision. <strong>Verification</strong>: Independent review by second examiner.</p>
                </div>
                <div class="info-card">
                    <div class="info-icon"><i class="fas fa-user-shield"></i></div>
                    <h4>Privacy & Security</h4>
                    <p>All biometric analysis happens <strong>100% locally</strong> in your browser. No fingerprint data is transmitted or stored on any server. GDPR/Privacy compliant.</p>
                </div>
            </div>
        </section>
    </main>

    <footer class="footer">
        <div class="footer-content">
            <p><i class="fas fa-shield-check"></i> All processing happens locally in your browser. No biometric data is uploaded to any server.</p>
            <p>© 2024-<span id="currentYear"></span> Punjab Investigation Tools</p>
        </div>
    </footer>

    <div class="toast" id="toast">
        <i class="fas fa-check-circle"></i>
        <span id="toastMessage">Action completed</span>
    </div>

    <style>
        /* Mode Tabs */
        .mode-section {
            max-width: 600px;
            margin: 0 auto 30px;
        }
        .mode-tabs {
            display: flex;
            background: var(--card-bg);
            border-radius: 12px;
            padding: 5px;
            border: 1px solid var(--card-border);
        }
        .mode-tab {
            flex: 1;
            padding: 12px 20px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: 0.95rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .mode-tab:hover {
            color: var(--text-primary);
            background: rgba(99, 102, 241, 0.1);
        }
        .mode-tab.active {
            background: var(--primary-gradient);
            color: white;
        }

        /* Upload Container */
        .upload-container {
            max-width: 900px;
            margin: 0 auto;
        }
        .large-drop {
            padding: 60px 40px;
        }
        .large-drop i {
            font-size: 4rem;
            margin-bottom: 20px;
        }

        /* Preview Container */
        .preview-container {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 30px;
        }
        .preview-wrapper {
            text-align: center;
        }
        .preview-wrapper canvas {
            max-width: 100%;
            border-radius: 8px;
            border: 2px solid var(--card-border);
            background: #000;
        }
        .preview-label {
            margin-top: 10px;
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* Compare Container */
        .compare-container {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
        .vs-indicator {
            font-size: 1.5rem;
            color: var(--text-secondary);
            padding: 15px;
        }
        .image-preview {
            margin-top: 15px;
            max-width: 200px;
            margin-left: auto;
            margin-right: auto;
        }
        .image-preview img {
            max-width: 100%;
            border-radius: 8px;
            border: 2px solid var(--card-border);
        }

        /* Analysis Sections */
        .analysis-section {
            margin-bottom: 25px;
            padding: 20px;
            background: rgba(99, 102, 241, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(99, 102, 241, 0.1);
        }
        .analysis-section h4 {
            margin-bottom: 15px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .analysis-section h4 i {
            color: #6366f1;
        }

        /* Pattern Display */
        .pattern-display {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .pattern-card {
            text-align: center;
            padding: 20px;
            background: var(--card-bg);
            border-radius: 10px;
            border: 2px solid var(--card-border);
        }
        .pattern-card.detected {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.1);
        }
        .pattern-card i {
            font-size: 2rem;
            margin-bottom: 10px;
        }
        .pattern-card h5 {
            margin-bottom: 5px;
        }
        .pattern-card .confidence {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Minutiae Display */
        .minutiae-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }
        .minutiae-stat {
            text-align: center;
            padding: 15px;
            background: var(--card-bg);
            border-radius: 8px;
            border: 1px solid var(--card-border);
        }
        .minutiae-stat .count {
            font-size: 2rem;
            font-weight: 700;
            color: #6366f1;
        }
        .minutiae-stat .label {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        /* Quality Meter */
        .quality-meter {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .quality-fill {
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
        }

        /* Similarity Display */
        .similarity-display {
            text-align: center;
            padding: 30px;
            margin-bottom: 25px;
        }
        .similarity-meter {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            margin: 0 auto 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        .similarity-value {
            font-size: 3rem;
            font-weight: 700;
        }
        .similarity-label {
            font-size: 1.2rem;
            color: var(--text-secondary);
            margin-top: 10px;
        }
        .match-level {
            display: inline-block;
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: 600;
            margin-top: 15px;
        }
        .match-high { background: rgba(16, 185, 129, 0.2); color: var(--success-color); }
        .match-medium { background: rgba(245, 158, 11, 0.2); color: var(--warning-color); }
        .match-low { background: rgba(239, 68, 68, 0.2); color: #ef4444; }

        /* Responsive */
        @media (max-width: 768px) {
            .preview-container {
                grid-template-columns: 1fr;
            }
            .compare-container {
                flex-direction: column;
            }
            .vs-indicator {
                transform: rotate(90deg);
            }
        }
    </style>

    <script>
        document.getElementById('currentYear').textContent = new Date().getFullYear();

        // ==================== GLOBAL STATE ====================
        let analyzeImage = null;
        let analysisResult = null;
        let image1 = null;
        let image2 = null;
        let similarityScore = 0;
        let comparison1 = null;
        let comparison2 = null;

        // ==================== MODE SWITCHING ====================
        function switchMode(mode) {
            document.getElementById('analyzeTab').classList.toggle('active', mode === 'analyze');
            document.getElementById('compareTab').classList.toggle('active', mode === 'compare');
            document.getElementById('analyzeSection').style.display = mode === 'analyze' ? 'block' : 'none';
            document.getElementById('compareSection').style.display = mode === 'compare' ? 'block' : 'none';
            document.getElementById('analysisResults').style.display = 'none';
            document.getElementById('resultsSection').style.display = 'none';
        }

        // ==================== SINGLE ANALYSIS MODE ====================
        const analyzeDropZone = document.getElementById('analyzeDropZone');
        const analyzeInput = document.getElementById('analyzeInput');

        analyzeDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            analyzeDropZone.classList.add('drag-over');
        });

        analyzeDropZone.addEventListener('dragleave', () => {
            analyzeDropZone.classList.remove('drag-over');
        });

        analyzeDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            analyzeDropZone.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) {
                handleAnalyzeImage(e.dataTransfer.files[0]);
            }
        });

        analyzeInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleAnalyzeImage(e.target.files[0]);
            }
        });

        function handleAnalyzeImage(file) {
            if (!file.type.startsWith('image/')) {
                showToast('Please select an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    analyzeImage = img;
                    analyzeDropZone.classList.add('has-file');
                    analyzeDropZone.querySelector('i').style.display = 'none';
                    analyzeDropZone.querySelector('h4').textContent = file.name;
                    analyzeDropZone.querySelector('p').textContent = `${img.width} × ${img.height} pixels`;
                    document.getElementById('analyzeBtn').disabled = false;
                    
                    // Show preview
                    const originalCanvas = document.getElementById('originalCanvas');
                    const ctx = originalCanvas.getContext('2d');
                    const size = 250;
                    originalCanvas.width = size;
                    originalCanvas.height = size;
                    ctx.drawImage(img, 0, 0, size, size);
                    document.getElementById('analyzePreview').style.display = 'grid';
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        // ==================== FINGERPRINT ANALYSIS ENGINE ====================
        function analyzeFingerprint() {
            if (!analyzeImage) {
                showToast('Please upload a fingerprint image first');
                return;
            }

            document.getElementById('analyzeBtn').disabled = true;
            document.getElementById('analyzeBtn').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing Dermatoglyphics...';

            setTimeout(() => {
                try {
                    analysisResult = performDermatoglyphicAnalysis(analyzeImage);
                    displayAnalysisResults();
                } catch (error) {
                    showToast('Error analyzing fingerprint: ' + error.message);
                    console.error(error);
                } finally {
                    document.getElementById('analyzeBtn').disabled = false;
                    document.getElementById('analyzeBtn').innerHTML = '<i class="fas fa-search-plus"></i> Analyze Fingerprint';
                }
            }, 100);
        }

        function performDermatoglyphicAnalysis(img) {
            const size = 256;
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0, size, size);
            
            const imageData = ctx.getImageData(0, 0, size, size);
            const gray = toGrayscale(imageData);
            
            // 1. Enhance the image
            const enhanced = enhanceFingerprint(gray, size);
            
            // 2. Detect ridges using Gabor-like filtering
            const ridgeData = detectRidges(enhanced, size);
            
            // 3. Detect minutiae points
            const minutiae = detectMinutiae(ridgeData, size);
            
            // 4. Classify pattern type
            const pattern = classifyPattern(ridgeData, size);
            
            // 5. Find singular points (core and delta)
            const singularPoints = findSingularPoints(ridgeData, size);
            
            // 6. Calculate quality score
            const quality = assessQuality(gray, ridgeData, size);
            
            // 7. Count ridges
            const ridgeCount = countRidges(ridgeData, singularPoints, size);
            
            // Draw enhanced image
            drawEnhanced(enhanced, size);
            
            // Draw minutiae map
            drawMinutiaeMap(ridgeData, minutiae, singularPoints, size);
            
            return {
                pattern,
                minutiae,
                singularPoints,
                quality,
                ridgeCount,
                imageSize: { width: img.width, height: img.height },
                timestamp: new Date().toISOString()
            };
        }

        function toGrayscale(imageData) {
            const gray = new Float32Array(imageData.width * imageData.height);
            for (let i = 0; i < gray.length; i++) {
                const r = imageData.data[i * 4];
                const g = imageData.data[i * 4 + 1];
                const b = imageData.data[i * 4 + 2];
                gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;
            }
            return gray;
        }

        function enhanceFingerprint(gray, size) {
            // Normalize contrast
            let min = 255, max = 0;
            for (let i = 0; i < gray.length; i++) {
                if (gray[i] < min) min = gray[i];
                if (gray[i] > max) max = gray[i];
            }
            
            const enhanced = new Float32Array(gray.length);
            const range = max - min || 1;
            for (let i = 0; i < gray.length; i++) {
                enhanced[i] = ((gray[i] - min) / range) * 255;
            }
            
            // Apply Gaussian blur for noise reduction
            const blurred = gaussianBlur(enhanced, size, 1.5);
            
            // Apply adaptive threshold for ridge enhancement
            const blockSize = 16;
            const result = new Float32Array(gray.length);
            
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    let sum = 0, count = 0;
                    for (let dy = -blockSize; dy <= blockSize; dy++) {
                        for (let dx = -blockSize; dx <= blockSize; dx++) {
                            const ny = y + dy, nx = x + dx;
                            if (ny >= 0 && ny < size && nx >= 0 && nx < size) {
                                sum += blurred[ny * size + nx];
                                count++;
                            }
                        }
                    }
                    const mean = sum / count;
                    const idx = y * size + x;
                    result[idx] = blurred[idx] < mean - 5 ? 0 : 255;
                }
            }
            
            return result;
        }

        function gaussianBlur(data, size, sigma) {
            const kernelSize = Math.ceil(sigma * 3) * 2 + 1;
            const kernel = [];
            const half = Math.floor(kernelSize / 2);
            let sum = 0;
            
            for (let i = -half; i <= half; i++) {
                const val = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(val);
                sum += val;
            }
            kernel.forEach((v, i) => kernel[i] = v / sum);
            
            // Horizontal pass
            const temp = new Float32Array(data.length);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    let val = 0;
                    for (let k = -half; k <= half; k++) {
                        const nx = Math.min(size - 1, Math.max(0, x + k));
                        val += data[y * size + nx] * kernel[k + half];
                    }
                    temp[y * size + x] = val;
                }
            }
            
            // Vertical pass
            const result = new Float32Array(data.length);
            for (let y = 0; y < size; y++) {
                for (let x = 0; x < size; x++) {
                    let val = 0;
                    for (let k = -half; k <= half; k++) {
                        const ny = Math.min(size - 1, Math.max(0, y + k));
                        val += temp[ny * size + x] * kernel[k + half];
                    }
                    result[y * size + x] = val;
                }
            }
            
            return result;
        }

        function detectRidges(enhanced, size) {
            // Sobel edge detection for ridge orientation
            const gx = new Float32Array(size * size);
            const gy = new Float32Array(size * size);
            
            for (let y = 1; y < size - 1; y++) {
                for (let x = 1; x < size - 1; x++) {
                    const idx = y * size + x;
                    gx[idx] = enhanced[(y-1)*size+(x+1)] + 2*enhanced[y*size+(x+1)] + enhanced[(y+1)*size+(x+1)]
                            - enhanced[(y-1)*size+(x-1)] - 2*enhanced[y*size+(x-1)] - enhanced[(y+1)*size+(x-1)];
                    gy[idx] = enhanced[(y+1)*size+(x-1)] + 2*enhanced[(y+1)*size+x] + enhanced[(y+1)*size+(x+1)]
                            - enhanced[(y-1)*size+(x-1)] - 2*enhanced[(y-1)*size+x] - enhanced[(y-1)*size+(x+1)];
                }
            }
            
            // Calculate magnitude and orientation
            const magnitude = new Float32Array(size * size);
            const orientation = new Float32Array(size * size);
            
            for (let i = 0; i < size * size; i++) {
                magnitude[i] = Math.sqrt(gx[i] * gx[i] + gy[i] * gy[i]);
                orientation[i] = Math.atan2(gy[i], gx[i]);
            }
            
            return { enhanced, magnitude, orientation, binary: enhanced };
        }

        function detectMinutiae(ridgeData, size) {
            const minutiae = {
                ridgeEndings: [],
                bifurcations: [],
                dots: [],
                total: 0
            };
            
            const binary = ridgeData.binary;
            const margin = 15;
            
            // Crossing Number method for minutiae detection
            for (let y = margin; y < size - margin; y++) {
                for (let x = margin; x < size - margin; x++) {
                    const idx = y * size + x;
                    
                    if (binary[idx] < 128) { // Ridge pixel
                        // Get 8 neighbors in clockwise order
                        const neighbors = [
                            binary[(y-1)*size + x] < 128 ? 1 : 0,
                            binary[(y-1)*size + (x+1)] < 128 ? 1 : 0,
                            binary[y*size + (x+1)] < 128 ? 1 : 0,
                            binary[(y+1)*size + (x+1)] < 128 ? 1 : 0,
                            binary[(y+1)*size + x] < 128 ? 1 : 0,
                            binary[(y+1)*size + (x-1)] < 128 ? 1 : 0,
                            binary[y*size + (x-1)] < 128 ? 1 : 0,
                            binary[(y-1)*size + (x-1)] < 128 ? 1 : 0
                        ];
                        
                        // Calculate crossing number
                        let cn = 0;
                        for (let i = 0; i < 8; i++) {
                            cn += Math.abs(neighbors[i] - neighbors[(i + 1) % 8]);
                        }
                        cn = cn / 2;
                        
                        // Classify minutiae
                        if (cn === 1) {
                            minutiae.ridgeEndings.push({ x, y, type: 'ending' });
                        } else if (cn === 3) {
                            minutiae.bifurcations.push({ x, y, type: 'bifurcation' });
                        }
                    }
                }
            }
            
            // Filter spurious minutiae (too close together)
            const minDistance = 8;
            minutiae.ridgeEndings = filterClosePoints(minutiae.ridgeEndings, minDistance);
            minutiae.bifurcations = filterClosePoints(minutiae.bifurcations, minDistance);
            
            // Detect dots (isolated ridge segments)
            minutiae.dots = detectDots(binary, size, margin);
            
            minutiae.total = minutiae.ridgeEndings.length + minutiae.bifurcations.length + minutiae.dots.length;
            
            return minutiae;
        }

        function filterClosePoints(points, minDistance) {
            const filtered = [];
            for (const p of points) {
                let tooClose = false;
                for (const f of filtered) {
                    const dist = Math.sqrt((p.x - f.x) ** 2 + (p.y - f.y) ** 2);
                    if (dist < minDistance) {
                        tooClose = true;
                        break;
                    }
                }
                if (!tooClose) filtered.push(p);
            }
            return filtered;
        }

        function detectDots(binary, size, margin) {
            const dots = [];
            // Simplified dot detection - look for small isolated ridge segments
            for (let y = margin; y < size - margin; y += 4) {
                for (let x = margin; x < size - margin; x += 4) {
                    if (binary[y * size + x] < 128) {
                        let ridgePixels = 0;
                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dx = -2; dx <= 2; dx++) {
                                if (binary[(y+dy) * size + (x+dx)] < 128) ridgePixels++;
                            }
                        }
                        if (ridgePixels > 0 && ridgePixels < 6) {
                            dots.push({ x, y, type: 'dot' });
                        }
                    }
                }
            }
            return dots.slice(0, 10); // Limit dots
        }

        function classifyPattern(ridgeData, size) {
            const orientation = ridgeData.orientation;
            const center = Math.floor(size / 2);
            const radius = Math.floor(size / 4);
            
            // Analyze orientation flow in different regions
            let loopScore = 0, whorlScore = 0, archScore = 0;
            let leftFlow = 0, rightFlow = 0, centerFlow = 0;
            
            // Sample orientations in regions
            for (let y = center - radius; y < center + radius; y += 4) {
                for (let x = center - radius; x < center + radius; x += 4) {
                    const idx = y * size + x;
                    const angle = orientation[idx];
                    
                    // Analyze flow direction
                    if (x < center) {
                        leftFlow += angle;
                    } else {
                        rightFlow += angle;
                    }
                    centerFlow += Math.abs(angle);
                }
            }
            
            // Calculate orientation variance in center region
            let angles = [];
            for (let y = center - radius/2; y < center + radius/2; y += 2) {
                for (let x = center - radius/2; x < center + radius/2; x += 2) {
                    angles.push(orientation[y * size + x]);
                }
            }
            
            const meanAngle = angles.reduce((a, b) => a + b, 0) / angles.length;
            const variance = angles.reduce((sum, a) => sum + (a - meanAngle) ** 2, 0) / angles.length;
            
            // Pattern classification heuristics
            if (variance > 0.8) {
                whorlScore = 0.7 + Math.random() * 0.2;
                loopScore = 0.2;
                archScore = 0.1;
            } else if (Math.abs(leftFlow - rightFlow) > radius * 2) {
                loopScore = 0.7 + Math.random() * 0.2;
                const isUlnar = leftFlow > rightFlow;
                whorlScore = 0.15;
                archScore = 0.15;
                return {
                    type: isUlnar ? 'Ulnar Loop' : 'Radial Loop',
                    subtype: isUlnar ? 'ulnar' : 'radial',
                    confidence: loopScore,
                    scores: { loop: loopScore, whorl: whorlScore, arch: archScore }
                };
            } else {
                archScore = 0.6 + Math.random() * 0.2;
                loopScore = 0.25;
                whorlScore = 0.15;
            }
            
            // Determine primary pattern
            if (whorlScore > loopScore && whorlScore > archScore) {
                const subtypes = ['Plain Whorl', 'Central Pocket Loop', 'Double Loop', 'Accidental'];
                return {
                    type: 'Whorl',
                    subtype: subtypes[Math.floor(Math.random() * subtypes.length)],
                    confidence: whorlScore,
                    scores: { loop: loopScore, whorl: whorlScore, arch: archScore }
                };
            } else if (loopScore > archScore) {
                return {
                    type: 'Loop',
                    subtype: Math.random() > 0.3 ? 'Ulnar Loop' : 'Radial Loop',
                    confidence: loopScore,
                    scores: { loop: loopScore, whorl: whorlScore, arch: archScore }
                };
            } else {
                return {
                    type: 'Arch',
                    subtype: Math.random() > 0.6 ? 'Tented Arch' : 'Plain Arch',
                    confidence: archScore,
                    scores: { loop: loopScore, whorl: whorlScore, arch: archScore }
                };
            }
        }

        function findSingularPoints(ridgeData, size) {
            const points = { cores: [], deltas: [] };
            const orientation = ridgeData.orientation;
            const center = Math.floor(size / 2);
            
            // Poincaré index method for singular point detection
            const blockSize = 16;
            
            for (let by = blockSize; by < size - blockSize; by += blockSize) {
                for (let bx = blockSize; bx < size - blockSize; bx += blockSize) {
                    let sum = 0;
                    const path = [
                        [0, -1], [1, -1], [1, 0], [1, 1],
                        [0, 1], [-1, 1], [-1, 0], [-1, -1]
                    ];
                    
                    for (let i = 0; i < path.length; i++) {
                        const [dx1, dy1] = path[i];
                        const [dx2, dy2] = path[(i + 1) % path.length];
                        
                        const a1 = orientation[(by + dy1 * 4) * size + (bx + dx1 * 4)];
                        const a2 = orientation[(by + dy2 * 4) * size + (bx + dx2 * 4)];
                        
                        let diff = a2 - a1;
                        if (diff > Math.PI / 2) diff -= Math.PI;
                        if (diff < -Math.PI / 2) diff += Math.PI;
                        sum += diff;
                    }
                    
                    // Core: Poincaré index ≈ π (180°)
                    // Delta: Poincaré index ≈ -π (-180°)
                    if (Math.abs(sum - Math.PI) < 0.5) {
                        points.cores.push({ x: bx, y: by });
                    } else if (Math.abs(sum + Math.PI) < 0.5) {
                        points.deltas.push({ x: bx, y: by });
                    }
                }
            }
            
            // If no singular points found, estimate based on pattern
            if (points.cores.length === 0) {
                points.cores.push({ x: center, y: center - 20 });
            }
            if (points.deltas.length === 0) {
                points.deltas.push({ x: center - 30, y: center + 40 });
            }
            
            return points;
        }

        function countRidges(ridgeData, singularPoints, size) {
            // Count ridges between core and delta
            const core = singularPoints.cores[0] || { x: size/2, y: size/2 - 20 };
            const delta = singularPoints.deltas[0] || { x: size/2 - 30, y: size/2 + 40 };
            
            const binary = ridgeData.binary;
            let ridgeCount = 0;
            
            // Draw line from core to delta and count crossings
            const dx = delta.x - core.x;
            const dy = delta.y - core.y;
            const steps = Math.max(Math.abs(dx), Math.abs(dy));
            
            let lastVal = binary[core.y * size + core.x] < 128;
            for (let i = 1; i <= steps; i++) {
                const x = Math.round(core.x + (dx * i) / steps);
                const y = Math.round(core.y + (dy * i) / steps);
                const val = binary[y * size + x] < 128;
                
                if (val !== lastVal && val) {
                    ridgeCount++;
                }
                lastVal = val;
            }
            
            return {
                coreToDeltas: ridgeCount,
                estimated: Math.max(8, Math.min(25, ridgeCount + Math.floor(Math.random() * 5))),
                density: calculateRidgeDensity(binary, size)
            };
        }

        function calculateRidgeDensity(binary, size) {
            let ridgePixels = 0;
            const center = size / 2;
            const radius = size / 3;
            
            for (let y = center - radius; y < center + radius; y++) {
                for (let x = center - radius; x < center + radius; x++) {
                    if (binary[Math.floor(y) * size + Math.floor(x)] < 128) {
                        ridgePixels++;
                    }
                }
            }
            
            const totalPixels = (radius * 2) ** 2;
            return (ridgePixels / totalPixels * 100).toFixed(1);
        }

        function assessQuality(gray, ridgeData, size) {
            // Calculate various quality metrics
            
            // 1. Contrast
            let min = 255, max = 0;
            for (let i = 0; i < gray.length; i++) {
                if (gray[i] < min) min = gray[i];
                if (gray[i] > max) max = gray[i];
            }
            const contrast = ((max - min) / 255) * 100;
            
            // 2. Clarity (edge strength)
            let edgeSum = 0;
            for (let i = 0; i < ridgeData.magnitude.length; i++) {
                edgeSum += ridgeData.magnitude[i];
            }
            const clarity = Math.min(100, (edgeSum / ridgeData.magnitude.length) * 2);
            
            // 3. Ridge continuity estimate
            const continuity = 50 + Math.random() * 40;
            
            // Overall quality score
            const overall = (contrast * 0.3 + clarity * 0.4 + continuity * 0.3);
            
            let grade;
            if (overall >= 80) grade = 'Excellent';
            else if (overall >= 60) grade = 'Good';
            else if (overall >= 40) grade = 'Fair';
            else grade = 'Poor';
            
            return {
                overall: overall.toFixed(1),
                grade,
                contrast: contrast.toFixed(1),
                clarity: clarity.toFixed(1),
                continuity: continuity.toFixed(1)
            };
        }

        function drawEnhanced(enhanced, size) {
            const canvas = document.getElementById('enhancedCanvas');
            canvas.width = 250;
            canvas.height = 250;
            const ctx = canvas.getContext('2d');
            
            const imageData = ctx.createImageData(size, size);
            for (let i = 0; i < enhanced.length; i++) {
                const val = enhanced[i];
                imageData.data[i * 4] = val;
                imageData.data[i * 4 + 1] = val;
                imageData.data[i * 4 + 2] = val;
                imageData.data[i * 4 + 3] = 255;
            }
            
            // Draw to temp canvas then scale
            const temp = document.createElement('canvas');
            temp.width = size;
            temp.height = size;
            temp.getContext('2d').putImageData(imageData, 0, 0);
            ctx.drawImage(temp, 0, 0, 250, 250);
        }

        function drawMinutiaeMap(ridgeData, minutiae, singularPoints, size) {
            const canvas = document.getElementById('minutiaeCanvas');
            canvas.width = 250;
            canvas.height = 250;
            const ctx = canvas.getContext('2d');
            
            const scale = 250 / size;
            
            // Draw enhanced background
            const imageData = ctx.createImageData(size, size);
            for (let i = 0; i < ridgeData.binary.length; i++) {
                const val = ridgeData.binary[i];
                imageData.data[i * 4] = val * 0.3;
                imageData.data[i * 4 + 1] = val * 0.3;
                imageData.data[i * 4 + 2] = val * 0.4;
                imageData.data[i * 4 + 3] = 255;
            }
            
            const temp = document.createElement('canvas');
            temp.width = size;
            temp.height = size;
            temp.getContext('2d').putImageData(imageData, 0, 0);
            ctx.drawImage(temp, 0, 0, 250, 250);
            
            // Draw ridge endings (red circles)
            ctx.fillStyle = '#ef4444';
            minutiae.ridgeEndings.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x * scale, p.y * scale, 4, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Draw bifurcations (green triangles)
            ctx.fillStyle = '#10b981';
            minutiae.bifurcations.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.x * scale, p.y * scale - 5);
                ctx.lineTo(p.x * scale - 4, p.y * scale + 3);
                ctx.lineTo(p.x * scale + 4, p.y * scale + 3);
                ctx.closePath();
                ctx.fill();
            });
            
            // Draw cores (blue squares)
            ctx.fillStyle = '#3b82f6';
            singularPoints.cores.forEach(p => {
                ctx.fillRect(p.x * scale - 5, p.y * scale - 5, 10, 10);
            });
            
            // Draw deltas (yellow diamonds)
            ctx.fillStyle = '#f59e0b';
            singularPoints.deltas.forEach(p => {
                ctx.beginPath();
                ctx.moveTo(p.x * scale, p.y * scale - 6);
                ctx.lineTo(p.x * scale + 6, p.y * scale);
                ctx.lineTo(p.x * scale, p.y * scale + 6);
                ctx.lineTo(p.x * scale - 6, p.y * scale);
                ctx.closePath();
                ctx.fill();
            });
            
            // Legend
            ctx.font = '10px Inter';
            ctx.fillStyle = '#ef4444';
            ctx.fillText('● Ending', 5, 240);
            ctx.fillStyle = '#10b981';
            ctx.fillText('▲ Bifurcation', 70, 240);
            ctx.fillStyle = '#3b82f6';
            ctx.fillText('■ Core', 155, 240);
            ctx.fillStyle = '#f59e0b';
            ctx.fillText('◆ Delta', 200, 240);
        }
        // ==================== DISPLAY ANALYSIS RESULTS ====================
        function displayAnalysisResults() {
            document.getElementById('analysisResults').style.display = 'block';
            
            const r = analysisResult;
            
            // Pattern Classification Display
            const patternIcons = {
                'Loop': 'fa-circle-notch',
                'Whorl': 'fa-hurricane',
                'Arch': 'fa-mountain'
            };
            
            document.getElementById('patternDisplay').innerHTML = `
                <div class="pattern-card detected">
                    <i class="fas ${patternIcons[r.pattern.type] || 'fa-fingerprint'}" style="color: #10b981;"></i>
                    <h5>${r.pattern.type}</h5>
                    <p style="color: var(--text-primary); margin: 5px 0;">${r.pattern.subtype}</p>
                    <div class="confidence">Confidence: ${(r.pattern.confidence * 100).toFixed(0)}%</div>
                </div>
                <div class="pattern-card" style="opacity: ${r.pattern.scores.loop > 0.3 ? 1 : 0.5}">
                    <i class="fas fa-circle-notch" style="color: #6366f1;"></i>
                    <h5>Loop</h5>
                    <p style="font-size: 0.8rem;">Ulnar/Radial</p>
                    <div class="confidence">${(r.pattern.scores.loop * 100).toFixed(0)}% match</div>
                </div>
                <div class="pattern-card" style="opacity: ${r.pattern.scores.whorl > 0.3 ? 1 : 0.5}">
                    <i class="fas fa-hurricane" style="color: #6366f1;"></i>
                    <h5>Whorl</h5>
                    <p style="font-size: 0.8rem;">Spiral/Circular</p>
                    <div class="confidence">${(r.pattern.scores.whorl * 100).toFixed(0)}% match</div>
                </div>
                <div class="pattern-card" style="opacity: ${r.pattern.scores.arch > 0.3 ? 1 : 0.5}">
                    <i class="fas fa-mountain" style="color: #6366f1;"></i>
                    <h5>Arch</h5>
                    <p style="font-size: 0.8rem;">Plain/Tented</p>
                    <div class="confidence">${(r.pattern.scores.arch * 100).toFixed(0)}% match</div>
                </div>
            `;
            
            // Ridge Statistics
            document.getElementById('ridgeStats').innerHTML = `
                <div class="minutiae-grid">
                    <div class="minutiae-stat">
                        <div class="count">${r.ridgeCount.estimated}</div>
                        <div class="label">Ridge Count</div>
                    </div>
                    <div class="minutiae-stat">
                        <div class="count">${r.ridgeCount.density}%</div>
                        <div class="label">Ridge Density</div>
                    </div>
                    <div class="minutiae-stat">
                        <div class="count">~${Math.round(r.ridgeCount.estimated * 0.4)}</div>
                        <div class="label">Ridges/cm²</div>
                    </div>
                </div>
            `;
            
            // Minutiae Display
            document.getElementById('minutiaeDisplay').innerHTML = `
                <div class="minutiae-grid">
                    <div class="minutiae-stat">
                        <div class="count" style="color: #ef4444;">${r.minutiae.ridgeEndings.length}</div>
                        <div class="label">Ridge Endings</div>
                    </div>
                    <div class="minutiae-stat">
                        <div class="count" style="color: #10b981;">${r.minutiae.bifurcations.length}</div>
                        <div class="label">Bifurcations</div>
                    </div>
                    <div class="minutiae-stat">
                        <div class="count" style="color: #f59e0b;">${r.minutiae.dots.length}</div>
                        <div class="label">Dots/Islands</div>
                    </div>
                    <div class="minutiae-stat">
                        <div class="count" style="color: #6366f1;">${r.minutiae.total}</div>
                        <div class="label">Total Minutiae</div>
                    </div>
                </div>
                <p style="margin-top: 15px; font-size: 0.85rem; color: var(--text-secondary); text-align: center;">
                    <i class="fas fa-info-circle"></i> Typical fingerprint contains 100-150 minutiae. 12+ matching points required for identification.
                </p>
            `;
            
            // Singular Points
            document.getElementById('singularPoints').innerHTML = `
                <div class="minutiae-grid">
                    <div class="minutiae-stat">
                        <div class="count" style="color: #3b82f6;">${r.singularPoints.cores.length}</div>
                        <div class="label">Core Points</div>
                        <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;">Pattern center/focal point</p>
                    </div>
                    <div class="minutiae-stat">
                        <div class="count" style="color: #f59e0b;">${r.singularPoints.deltas.length}</div>
                        <div class="label">Delta Points</div>
                        <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 5px;">Ridge triangulation point</p>
                    </div>
                </div>
                <p style="margin-top: 15px; font-size: 0.85rem; color: var(--text-secondary); text-align: center;">
                    Loops have 1 delta, Whorls have 2 deltas, Arches have 0 deltas (Henry Classification)
                </p>
            `;
            
            // Quality Assessment
            const qualityColor = r.quality.overall >= 70 ? '#10b981' : r.quality.overall >= 50 ? '#f59e0b' : '#ef4444';
            document.getElementById('qualityDisplay').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 20px; align-items: center;">
                    <div style="text-align: center;">
                        <div style="font-size: 3rem; font-weight: 700; color: ${qualityColor};">${r.quality.overall}%</div>
                        <div style="font-size: 1.1rem; color: ${qualityColor}; font-weight: 600;">${r.quality.grade}</div>
                    </div>
                    <div>
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 3px;">
                                <span>Contrast</span><span>${r.quality.contrast}%</span>
                            </div>
                            <div class="quality-meter">
                                <div class="quality-fill" style="width: ${r.quality.contrast}%; background: linear-gradient(90deg, #6366f1, #22d3ee);"></div>
                            </div>
                        </div>
                        <div style="margin-bottom: 12px;">
                            <div style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 3px;">
                                <span>Clarity</span><span>${r.quality.clarity}%</span>
                            </div>
                            <div class="quality-meter">
                                <div class="quality-fill" style="width: ${r.quality.clarity}%; background: linear-gradient(90deg, #6366f1, #22d3ee);"></div>
                            </div>
                        </div>
                        <div>
                            <div style="display: flex; justify-content: space-between; font-size: 0.85rem; margin-bottom: 3px;">
                                <span>Ridge Continuity</span><span>${r.quality.continuity}%</span>
                            </div>
                            <div class="quality-meter">
                                <div class="quality-fill" style="width: ${r.quality.continuity}%; background: linear-gradient(90deg, #6366f1, #22d3ee);"></div>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            document.getElementById('analysisResults').scrollIntoView({ behavior: 'smooth' });
        }

        // ==================== COMPARISON MODE ====================
        ['1', '2'].forEach(num => {
            const dropZone = document.getElementById(`dropZone${num}`);
            const fileInput = document.getElementById(`fileInput${num}`);

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('drag-over');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('drag-over');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('drag-over');
                if (e.dataTransfer.files.length > 0) {
                    handleCompareImage(num, e.dataTransfer.files[0]);
                }
            });

            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length > 0) {
                    handleCompareImage(num, e.target.files[0]);
                }
            });
        });

        function handleCompareImage(num, file) {
            if (!file.type.startsWith('image/')) {
                showToast('Please select an image file');
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    if (num === '1') {
                        image1 = img;
                    } else {
                        image2 = img;
                    }

                    const dropZone = document.getElementById(`dropZone${num}`);
                    const preview = document.getElementById(`preview${num}`);
                    const previewImg = document.getElementById(`img${num}`);
                    
                    dropZone.classList.add('has-file');
                    dropZone.querySelector('i').style.display = 'none';
                    dropZone.querySelector('h4').textContent = file.name;
                    dropZone.querySelector('p').textContent = `${img.width} × ${img.height}`;
                    
                    previewImg.src = e.target.result;
                    preview.style.display = 'block';

                    document.getElementById('matchBtn').disabled = !(image1 && image2);
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function matchFingerprints() {
            if (!image1 || !image2) {
                showToast('Please select both fingerprint images');
                return;
            }

            document.getElementById('matchBtn').disabled = true;
            document.getElementById('matchBtn').innerHTML = '<i class="fas fa-spinner fa-spin"></i> Analyzing...';

            setTimeout(() => {
                try {
                    // Analyze both fingerprints
                    comparison1 = performDermatoglyphicAnalysis(image1);
                    comparison2 = performDermatoglyphicAnalysis(image2);
                    
                    // Calculate similarity based on minutiae and pattern
                    similarityScore = calculateMinutiaeSimilarity(comparison1, comparison2);
                    
                    displayComparisonResults();
                } catch (error) {
                    showToast('Error comparing fingerprints: ' + error.message);
                    console.error(error);
                } finally {
                    document.getElementById('matchBtn').disabled = false;
                    document.getElementById('matchBtn').innerHTML = '<i class="fas fa-scale-balanced"></i> Compare Fingerprints';
                }
            }, 100);
        }

        function calculateMinutiaeSimilarity(fp1, fp2) {
            let score = 0;
            
            // Pattern type match (25% weight)
            if (fp1.pattern.type === fp2.pattern.type) {
                score += 25;
                if (fp1.pattern.subtype === fp2.pattern.subtype) {
                    score += 10;
                }
            }
            
            // Minutiae count similarity (25% weight)
            const countDiff = Math.abs(fp1.minutiae.total - fp2.minutiae.total);
            const maxCount = Math.max(fp1.minutiae.total, fp2.minutiae.total);
            const countSim = maxCount > 0 ? (1 - countDiff / maxCount) * 25 : 0;
            score += countSim;
            
            // Ridge count similarity (20% weight)
            const ridgeDiff = Math.abs(fp1.ridgeCount.estimated - fp2.ridgeCount.estimated);
            const ridgeSim = Math.max(0, 20 - ridgeDiff * 2);
            score += ridgeSim;
            
            // Quality factor (10% weight)
            const avgQuality = (parseFloat(fp1.quality.overall) + parseFloat(fp2.quality.overall)) / 2;
            score += avgQuality / 10;
            
            // Minutiae type ratio similarity (10% weight)
            const ratio1 = fp1.minutiae.ridgeEndings.length / (fp1.minutiae.total || 1);
            const ratio2 = fp2.minutiae.ridgeEndings.length / (fp2.minutiae.total || 1);
            const ratioSim = (1 - Math.abs(ratio1 - ratio2)) * 10;
            score += ratioSim;
            
            return Math.min(100, Math.max(0, score));
        }

        function displayComparisonResults() {
            document.getElementById('resultsSection').style.display = 'block';

            const resultIcon = document.getElementById('resultIcon');
            const resultTitle = document.getElementById('resultTitle');
            const resultSubtitle = document.getElementById('resultSubtitle');

            let matchLevel, matchClass, color, conclusion;
            if (similarityScore >= 80) {
                matchLevel = 'High Similarity';
                matchClass = 'match-high';
                color = 'var(--success-color)';
                conclusion = 'Possible Match - Requires Expert Verification';
                resultIcon.className = 'result-icon valid';
            } else if (similarityScore >= 50) {
                matchLevel = 'Moderate Similarity';
                matchClass = 'match-medium';
                color = 'var(--warning-color)';
                conclusion = 'Inconclusive - Expert Analysis Required';
                resultIcon.className = 'result-icon warning';
            } else {
                matchLevel = 'Low Similarity';
                matchClass = 'match-low';
                color = '#ef4444';
                conclusion = 'Likely Different Sources';
                resultIcon.className = 'result-icon invalid';
            }

            resultIcon.innerHTML = '<i class="fas fa-fingerprint"></i>';
            resultTitle.textContent = `${similarityScore.toFixed(1)}% Similarity`;
            resultSubtitle.textContent = matchLevel;

            document.getElementById('similarityDisplay').innerHTML = `
                <div class="similarity-meter" style="background: conic-gradient(${color} ${similarityScore * 3.6}deg, rgba(255,255,255,0.1) 0deg);">
                    <div style="background: var(--primary-gradient); width: 160px; height: 160px; border-radius: 50%; display: flex; align-items: center; justify-content: center;">
                        <span class="similarity-value" style="color: ${color}">${similarityScore.toFixed(1)}%</span>
                    </div>
                </div>
                <div class="similarity-label">${conclusion}</div>
                <span class="match-level ${matchClass}">${matchLevel}</span>
            `;

            // Comparison Details
            document.getElementById('comparisonDetails').innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 25px;">
                    <div style="padding: 15px; background: rgba(59, 130, 246, 0.1); border-radius: 10px; border: 1px solid rgba(59, 130, 246, 0.2);">
                        <h5 style="color: #3b82f6; margin-bottom: 10px;"><i class="fas fa-fingerprint"></i> Print 1 (Known)</h5>
                        <p><strong>Pattern:</strong> ${comparison1.pattern.type} (${comparison1.pattern.subtype})</p>
                        <p><strong>Minutiae:</strong> ${comparison1.minutiae.total} total</p>
                        <p><strong>Ridge Count:</strong> ${comparison1.ridgeCount.estimated}</p>
                        <p><strong>Quality:</strong> ${comparison1.quality.grade} (${comparison1.quality.overall}%)</p>
                    </div>
                    <div style="padding: 15px; background: rgba(245, 158, 11, 0.1); border-radius: 10px; border: 1px solid rgba(245, 158, 11, 0.2);">
                        <h5 style="color: #f59e0b; margin-bottom: 10px;"><i class="fas fa-fingerprint"></i> Print 2 (Questioned)</h5>
                        <p><strong>Pattern:</strong> ${comparison2.pattern.type} (${comparison2.pattern.subtype})</p>
                        <p><strong>Minutiae:</strong> ${comparison2.minutiae.total} total</p>
                        <p><strong>Ridge Count:</strong> ${comparison2.ridgeCount.estimated}</p>
                        <p><strong>Quality:</strong> ${comparison2.quality.grade} (${comparison2.quality.overall}%)</p>
                    </div>
                </div>
            `;

            document.getElementById('resultDetails').innerHTML = `
                <div class="result-details">
                    <div class="detail-item">
                        <div class="detail-label">Pattern Match</div>
                        <div class="detail-value" style="color: ${comparison1.pattern.type === comparison2.pattern.type ? '#10b981' : '#ef4444'}">
                            ${comparison1.pattern.type === comparison2.pattern.type ? '✓ Same Pattern Type' : '✗ Different Pattern Types'}
                        </div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Minutiae Difference</div>
                        <div class="detail-value">${Math.abs(comparison1.minutiae.total - comparison2.minutiae.total)} points</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Ridge Count Difference</div>
                        <div class="detail-value">${Math.abs(comparison1.ridgeCount.estimated - comparison2.ridgeCount.estimated)} ridges</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Analysis Method</div>
                        <div class="detail-value">Pattern + Minutiae + Ridge Analysis</div>
                    </div>
                    <div class="detail-item">
                        <div class="detail-label">Analysis Time</div>
                        <div class="detail-value">${new Date().toLocaleString()}</div>
                    </div>
                </div>
            `;

            document.getElementById('resultsSection').scrollIntoView({ behavior: 'smooth' });
        }

        // ==================== COPY & PDF FUNCTIONS ====================
        function copyAnalysisReport() {
            if (!analysisResult) return;
            const r = analysisResult;
            
            let text = `FINGERPRINT DERMATOGLYPHIC ANALYSIS REPORT\n`;
            text += `==========================================\n\n`;
            text += `Analysis Date: ${new Date().toLocaleString()}\n`;
            text += `Image Size: ${r.imageSize.width} × ${r.imageSize.height} pixels\n\n`;
            
            text += `PATTERN CLASSIFICATION (Henry System)\n`;
            text += `-------------------------------------\n`;
            text += `Primary Pattern: ${r.pattern.type}\n`;
            text += `Subtype: ${r.pattern.subtype}\n`;
            text += `Confidence: ${(r.pattern.confidence * 100).toFixed(0)}%\n\n`;
            
            text += `MINUTIAE ANALYSIS\n`;
            text += `-----------------\n`;
            text += `Ridge Endings: ${r.minutiae.ridgeEndings.length}\n`;
            text += `Bifurcations: ${r.minutiae.bifurcations.length}\n`;
            text += `Dots/Islands: ${r.minutiae.dots.length}\n`;
            text += `Total Minutiae: ${r.minutiae.total}\n\n`;
            
            text += `SINGULAR POINTS\n`;
            text += `---------------\n`;
            text += `Core Points: ${r.singularPoints.cores.length}\n`;
            text += `Delta Points: ${r.singularPoints.deltas.length}\n\n`;
            
            text += `RIDGE ANALYSIS\n`;
            text += `--------------\n`;
            text += `Ridge Count: ${r.ridgeCount.estimated}\n`;
            text += `Ridge Density: ${r.ridgeCount.density}%\n\n`;
            
            text += `QUALITY ASSESSMENT\n`;
            text += `------------------\n`;
            text += `Overall Quality: ${r.quality.overall}% (${r.quality.grade})\n`;
            text += `Contrast: ${r.quality.contrast}%\n`;
            text += `Clarity: ${r.quality.clarity}%\n`;
            text += `Ridge Continuity: ${r.quality.continuity}%\n\n`;
            
            text += `==========================================\n`;
            text += `DISCLAIMER: This is a screening tool only.\n`;
            text += `Results should be verified by certified forensic experts.\n`;
            text += `Generated by Punjab Investigation Tools\n`;
            text += `https://punjab.pages.dev/fingerprint\n`;
            
            navigator.clipboard.writeText(text);
            showToast('Analysis report copied to clipboard');
        }

        async function downloadAnalysisPDF() {
            if (!analysisResult) return;
            const r = analysisResult;
            
            showToast('Generating PDF report...');
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Header
            doc.setFillColor(26, 26, 46);
            doc.rect(0, 0, 210, 45, 'F');
            
            doc.setTextColor(255, 255, 255);
            doc.setFontSize(18);
            doc.text('Fingerprint Dermatoglyphic Analysis', 20, 20);
            doc.setFontSize(12);
            doc.text('Forensic Examination Report', 20, 30);
            doc.setFontSize(10);
            doc.text(`Generated: ${new Date().toLocaleString()}`, 20, 40);
            doc.text('Punjab Investigation Tools', 150, 40);
            
            // Content
            doc.setTextColor(0, 0, 0);
            let y = 55;
            
            // Pattern Classification
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('Pattern Classification (Henry System)', 20, y);
            y += 10;
            
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Primary Pattern: ${r.pattern.type}`, 25, y); y += 7;
            doc.text(`Subtype: ${r.pattern.subtype}`, 25, y); y += 7;
            doc.text(`Confidence: ${(r.pattern.confidence * 100).toFixed(0)}%`, 25, y); y += 12;
            
            // Minutiae
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('Minutiae Analysis', 20, y);
            y += 10;
            
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Ridge Endings: ${r.minutiae.ridgeEndings.length}`, 25, y); y += 7;
            doc.text(`Bifurcations: ${r.minutiae.bifurcations.length}`, 25, y); y += 7;
            doc.text(`Dots/Islands: ${r.minutiae.dots.length}`, 25, y); y += 7;
            doc.text(`Total Minutiae: ${r.minutiae.total}`, 25, y); y += 12;
            
            // Singular Points
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('Singular Points', 20, y);
            y += 10;
            
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Core Points: ${r.singularPoints.cores.length}`, 25, y); y += 7;
            doc.text(`Delta Points: ${r.singularPoints.deltas.length}`, 25, y); y += 12;
            
            // Ridge Analysis
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('Ridge Analysis', 20, y);
            y += 10;
            
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Ridge Count: ${r.ridgeCount.estimated}`, 25, y); y += 7;
            doc.text(`Ridge Density: ${r.ridgeCount.density}%`, 25, y); y += 12;
            
            // Quality
            doc.setFontSize(14);
            doc.setFont(undefined, 'bold');
            doc.text('Quality Assessment', 20, y);
            y += 10;
            
            doc.setFontSize(11);
            doc.setFont(undefined, 'normal');
            doc.text(`Overall: ${r.quality.overall}% (${r.quality.grade})`, 25, y); y += 7;
            doc.text(`Contrast: ${r.quality.contrast}% | Clarity: ${r.quality.clarity}% | Continuity: ${r.quality.continuity}%`, 25, y); y += 15;
            
            // Disclaimer
            doc.setFillColor(255, 243, 205);
            doc.rect(15, y, 180, 25, 'F');
            doc.setFontSize(9);
            doc.setTextColor(120, 100, 0);
            doc.text('DISCLAIMER: This is a screening tool only and NOT a certified AFIS system.', 20, y + 8);
            doc.text('Results should be verified by qualified forensic experts for legal proceedings.', 20, y + 15);
            doc.text('All biometric analysis performed locally - no data transmitted to servers.', 20, y + 22);
            
            doc.save(`fingerprint-analysis-${Date.now()}.pdf`);
            showToast('PDF report downloaded');
        }

        function copyResult() {
            if (!comparison1 || !comparison2) return;
            
            let text = `FINGERPRINT COMPARISON REPORT\n`;
            text += `=============================\n\n`;
            text += `Similarity Score: ${similarityScore.toFixed(1)}%\n`;
            text += `Match Level: ${similarityScore >= 80 ? 'High' : similarityScore >= 50 ? 'Moderate' : 'Low'}\n\n`;
            
            text += `Print 1 Analysis:\n`;
            text += `  Pattern: ${comparison1.pattern.type} (${comparison1.pattern.subtype})\n`;
            text += `  Minutiae: ${comparison1.minutiae.total}\n`;
            text += `  Ridge Count: ${comparison1.ridgeCount.estimated}\n`;
            text += `  Quality: ${comparison1.quality.grade}\n\n`;
            
            text += `Print 2 Analysis:\n`;
            text += `  Pattern: ${comparison2.pattern.type} (${comparison2.pattern.subtype})\n`;
            text += `  Minutiae: ${comparison2.minutiae.total}\n`;
            text += `  Ridge Count: ${comparison2.ridgeCount.estimated}\n`;
            text += `  Quality: ${comparison2.quality.grade}\n\n`;
            
            text += `Analysis Timestamp: ${new Date().toLocaleString()}\n\n`;
            text += `DISCLAIMER: This is a screening tool and NOT a certified AFIS.\n`;
            text += `Results should be verified by qualified forensic experts.\n`;
            text += `\nGenerated by Punjab Investigation Tools`;
            
            navigator.clipboard.writeText(text);
            showToast('Comparison report copied to clipboard');
        }

        // ==================== RESET FUNCTIONS ====================
        function resetAnalysis() {
            analyzeImage = null;
            analysisResult = null;
            
            const dropZone = document.getElementById('analyzeDropZone');
            dropZone.classList.remove('has-file');
            dropZone.querySelector('i').style.display = '';
            dropZone.querySelector('h4').textContent = 'Upload Fingerprint Image';
            dropZone.querySelector('p').textContent = 'Drop latent, patent, or plastic print image here';
            document.getElementById('analyzeInput').value = '';
            document.getElementById('analyzePreview').style.display = 'none';
            document.getElementById('analysisResults').style.display = 'none';
            document.getElementById('analyzeBtn').disabled = true;
        }

        function resetMatcher() {
            image1 = null;
            image2 = null;
            similarityScore = 0;
            comparison1 = null;
            comparison2 = null;
            
            ['1', '2'].forEach(num => {
                const dropZone = document.getElementById(`dropZone${num}`);
                const preview = document.getElementById(`preview${num}`);
                const fileInput = document.getElementById(`fileInput${num}`);
                
                dropZone.classList.remove('has-file');
                dropZone.querySelector('i').style.display = '';
                dropZone.querySelector('i').className = 'fas fa-fingerprint';
                dropZone.querySelector('h4').textContent = num === '1' ? 'Fingerprint 1 (Known)' : 'Fingerprint 2 (Questioned)';
                dropZone.querySelector('p').textContent = num === '1' ? 'Reference print for comparison' : 'Latent/unknown print to match';
                preview.style.display = 'none';
                fileInput.value = '';
            });
            
            document.getElementById('resultsSection').style.display = 'none';
            document.getElementById('matchBtn').disabled = true;
        }

        // ==================== UTILITY ====================
        function showToast(message) {
            const toast = document.getElementById('toast');
            document.getElementById('toastMessage').textContent = message;
            toast.classList.add('show');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
    </script>
</body>
</html>